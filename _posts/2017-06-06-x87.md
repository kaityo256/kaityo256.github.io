---
layout: post
title: "x87命令を使ってみる"
tags: [programming, qiita]
permalink: x87
---

# x87命令を使ってみる

## はじめに

少し前の記事ですが、x87命令である`fsin`や`fcos`が遅いとか精度がどうとか話題になっているようです。

参考→[サイン、コサインをインテルの CPU で計算すると少しバグっているらしい](http://tomeapp.jp/archives/1282)

x87の歴史については別記事(例えば[x86の浮動小数計算とSIMD命令の変遷](http://qiita.com/lpha_z/items/eafa9c13532c9ac80d4b))に譲りますが、ようするにもともと外付けとして実装されたFPUが、そのうち内部に統合されたのがx87です。そんなわけで、もともとはコプロセッサのことを指しましたが、今は命令セットとして扱われています。内部はスタックマシンになっており、しかもFPUデータレジスタはMMXレジスタと共有なので、一緒に使うとややこしいことになります。

前置きはともかく、さっそくx87命令を使ってみようと思います。

## そもそも最近のコンパイラはx87命令吐くの？

吐きます。[先の記事のコメント欄](http://qiita.com/lpha_z/items/eafa9c13532c9ac80d4b#comment-43cd68fd29360d60bcf9)にもあるように、long doubleを使うと、デフォルトでx87命令を吐きます。

```cpp
long double func(long double a, long double b){
  return a + b;
}
```

```shell-session
$ g++ -O3 -S ld.cpp
```

```nasm
func(long double, long double):
LFB0:
        fldt    24(%rsp)
        fldt    8(%rsp)
        faddp   %st, %st(1)
        ret
```

ここで出てる`fldt`とか`faddp`はx87命令です。

## なんでlong double使うとx87命令吐くの？

この辺詳しくないのですが、x86上のコンパイラの多くが`long double`の精度が80bitであり、x87に合わせてあるからだと思います。`sizeof(long double)`は16を返しますが、内部表現としては80bit精度の[拡張倍精度浮動小数点数](https://ja.wikipedia.org/wiki/%E6%8B%A1%E5%BC%B5%E5%80%8D%E7%B2%BE%E5%BA%A6%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E6%95%B0)になっています(多分)[^1]。なので、long doubleの計算をする際には、そのままの精度で80bit精度の計算ができるx87命令が呼ばれます。

[^1]: 筆者の手元の記録では、昔のx86系の石+gcc/icc`sizeof(long double)`は12を返していたようですが、DECのAlpha21264とDECのコンパイラは8を返していたようです。

ここで`fldt`は、メモリの値をレジスタスタックに積む命令ですが、最後の"t"はsource formatが「Extended」、すなわち80bitであることを表しています。これは、メモリ上の拡張倍精度浮動小数点数をそのままレジスタに積みます、という意味です。

## x87命令を使ってみる

というわけでx87命令を使ってみましょう。先述したように、x87命令の内部精度は80bitであり、通常扱う倍精度浮動小数点数は64bitですから、変換が必要になります。これはx87のスタックに積む命令が勝手にやってくれます。

例えば、`double`を受け取ってsinの値を返す関数はこんな感じになるでしょう。

```cpp
double
 __attribute__ ((noinline))
fsin(double a){
  double r;
  asm volatile (
      "movsd %%xmm0, %0\n\t" // 1.
      "fldl %0\n\t"          // 2.
      "fsin\n\t"             // 3.
      "fstpl %1\n\t"         // 4.
      :"=m"(a)
      :"m"(r)
    );
  return r;
}
```

やってることはこんな感じです。

1. `xmm0`に入ってきた引数を、一度メモリにコピーします [^2]
2. それを`fldl`命令でx87スタックレジスタに積みます。ここで`fldl`は「64bit倍精度を積む」命令で、このとき内部で80bit表現に変換されます。
3. `fsin`で、スタックの一番上にあるデータのsin値を計算します。
4. 計算された値がスタックの一番上に積んであるので、それをメモリに書き戻します。ここで80bit表現が64bit表現にコンバートされます。

[^2]: ちょっとアホなことをやっていますが、コンパイラの最適化で変なことが起きないようにするためです。もっと賢い方法があるかもしれません。

まぁその、これみて**遅そうだな**、と思っていただければ。いや、実際に速度を測定していないのでアレですが。

ちゃんとsinを計算できてるか確認しましょう。

```cpp
#include <stdio.h>
#include <math.h>

int
main(void){
  const int N = 10000;
  const double s = 2.0*M_PI/static_cast<double>(N);
  double x = 0.0;
  for(int i=0;i<N;i++){
    printf("%f %f\n",x, fsin(x));
    x += s;
  }
}
```

```shell-session
$ g++ test.cpp
$ ./a.out > test.dat
```

![image0.png](/assets/images/x87/image0.png)

計算できているみたいですね。

## まとめ

x87命令を使ってsin関数を計算してみました。x87は内部表現が80bitで通常の倍精度実数と異なるし、外付けFPUだったころの仕様を引きずっていたりしますが、まだちゃんと使えます(ダイの上でどう実装されているかは知りません)。おそらく過去のプログラムの互換性のためだけに残されているのだと思いますが、たまにこうやって使ってあげるとx87命令も喜ぶんじゃないでしょうか。

## 参考文献

* [CS:APP2e Web Aside ASM:X87:
X87-Based Support for Floating Point (PDF)](http://csapp.cs.cmu.edu/2e/waside/waside-x87.pdf)
